define('rsvp/all', ['./promise', 'exports'], (__dependency1__, __exports__) => {
  const Promise = __dependency1__.default; __exports__.default = function all (array, label) { return Promise.all(array, label) }
}); define('rsvp/all_settled', ['./promise', './utils', 'exports'], (__dependency1__, __dependency2__, __exports__) => {
  const Promise = __dependency1__.default; const isArray = __dependency2__.isArray; const isNonThenable = __dependency2__.isNonThenable; __exports__.default = function allSettled (entries, label) { return new Promise((resolve, reject) => { if (!isArray(entries)) { throw new TypeError('You must pass an array to allSettled.') } let remaining = entries.length; let entry; if (remaining === 0) { resolve([]); return } const results = new Array(remaining); function fulfilledResolver (index) { return function (value) { resolveAll(index, fulfilled(value)) } } function rejectedResolver (index) { return function (reason) { resolveAll(index, rejected(reason)) } } function resolveAll (index, value) { results[index] = value; if (--remaining === 0) { resolve(results) } } for (let index = 0; index < entries.length; index++) { entry = entries[index]; if (isNonThenable(entry)) { resolveAll(index, fulfilled(entry)) } else { Promise.resolve(entry).then(fulfilledResolver(index), rejectedResolver(index)) } } }, label) }; function fulfilled (value) { return { state: 'fulfilled', value } } function rejected (reason) { return { state: 'rejected', reason } }
}); define('rsvp/asap', ['exports'], (__exports__) => {
  __exports__.default = function asap (callback, arg) { const length = queue.push([callback, arg]); if (length === 1) { scheduleFlush() } }; const browserGlobal = typeof window !== 'undefined' ? window : {}; const BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver; function useNextTick () { return function () { process.nextTick(flush) } } function useMutationObserver () { let iterations = 0; const observer = new BrowserMutationObserver(flush); const node = document.createTextNode(''); observer.observe(node, { characterData: true }); return function () { node.data = iterations = ++iterations % 2 } } function useSetTimeout () { return function () { setTimeout(flush, 1) } } var queue = []; function flush () {
    for (let i = 0; i < queue.length; i++) {
      const tuple = queue[i]; let callback = tuple[0],
        arg = tuple[1]; callback(arg)
    }queue = []
  } let scheduleFlush; if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') { scheduleFlush = useNextTick() } else if (BrowserMutationObserver) { scheduleFlush = useMutationObserver() } else { scheduleFlush = useSetTimeout() }
}); define('rsvp/config', ['./events', 'exports'], (__dependency1__, __exports__) => {
  const EventTarget = __dependency1__.default; const config = { instrument: false }; EventTarget.mixin(config); function configure (name, value) { if (name === 'onerror') { config.on('error', value); return } if (arguments.length === 2) { config[name] = value } else { return config[name] } }__exports__.config = config; __exports__.configure = configure
}); define('rsvp/defer', ['./promise', 'exports'], (__dependency1__, __exports__) => {
  const Promise = __dependency1__.default; __exports__.default = function defer (label) { const deferred = {}; deferred.promise = new Promise((resolve, reject) => { deferred.resolve = resolve; deferred.reject = reject }, label); return deferred }
}); define('rsvp/events', ['exports'], (__exports__) => {
  const indexOf = function (callbacks, callback) { for (let i = 0, l = callbacks.length; i < l; i++) { if (callbacks[i] === callback) { return i } } return -1 }; const callbacksFor = function (object) { let callbacks = object._promiseCallbacks; if (!callbacks) { callbacks = object._promiseCallbacks = {} } return callbacks }; __exports__.default = { mixin (object) { object.on = this.on; object.off = this.off; object.trigger = this.trigger; object._promiseCallbacks = undefined; return object },
    on (eventName, callback) {
       let allCallbacks = callbacksFor(this),
        callbacks; callbacks = allCallbacks[eventName]; if (!callbacks) { callbacks = allCallbacks[eventName] = [] } if (indexOf(callbacks, callback) === -1) { callbacks.push(callback) }
     },
    off (eventName, callback) {
       let allCallbacks = callbacksFor(this),
        callbacks,
        index; if (!callback) { allCallbacks[eventName] = []; return }callbacks = allCallbacks[eventName]; index = indexOf(callbacks, callback); if (index !== -1) { callbacks.splice(index, 1) }
     },
    trigger (eventName, options) {
       let allCallbacks = callbacksFor(this),
        callbacks,
        callbackTuple,
        callback,
        binding; if (callbacks = allCallbacks[eventName]) { for (let i = 0; i < callbacks.length; i++) { callback = callbacks[i]; callback(options) } }
     } }
}); define('rsvp/filter', ['./all', './map', './utils', 'exports'], (__dependency1__, __dependency2__, __dependency3__, __exports__) => {
  const all = __dependency1__.default; const map = __dependency2__.default; const isFunction = __dependency3__.isFunction; const isArray = __dependency3__.isArray; function filter (promises, filterFn, label) {
     return all(promises, label).then((values) => {
      if (!isArray(promises)) { throw new TypeError('You must pass an array to filter.') } if (!isFunction(filterFn)) { throw new TypeError("You must pass a function to filter's second argument.") } return map(promises, filterFn, label).then((filterResults) => {
        let i,
           valuesLen = values.length,
           filtered = []; for (i = 0; i < valuesLen; i++) { if (filterResults[i])filtered.push(values[i]) } return filtered
      })
    })
   }__exports__.default = filter
}); define('rsvp/hash', ['./promise', './utils', 'exports'], (__dependency1__, __dependency2__, __exports__) => {
   const Promise = __dependency1__.default; const isNonThenable = __dependency2__.isNonThenable; const keysOf = __dependency2__.keysOf; __exports__.default = function hash (object, label) {
    return new Promise((resolve, reject) => {
      const results = {}; const keys = keysOf(object); let remaining = keys.length; let entry,
         property; if (remaining === 0) { resolve(results); return } function fulfilledTo (property) { return function (value) { results[property] = value; if (--remaining === 0) { resolve(results) } } } function onRejection (reason) { remaining = 0; reject(reason) } for (let i = 0; i < keys.length; i++) { property = keys[i]; entry = object[property]; if (isNonThenable(entry)) { results[property] = entry; if (--remaining === 0) { resolve(results) } } else { Promise.resolve(entry).then(fulfilledTo(property), onRejection) } }
    })
  }
 }); define('rsvp/hash_settled', ['./promise', './utils', 'exports'], (__dependency1__, __dependency2__, __exports__) => {
  const Promise = __dependency1__.default; const isNonThenable = __dependency2__.isNonThenable; const keysOf = __dependency2__.keysOf; __exports__.default = function hashSettled (object, label) {
    return new Promise((resolve, reject) => {
       const results = {}; const keys = keysOf(object); let remaining = keys.length; let entry,
        property; if (remaining === 0) { resolve(results); return } function fulfilledResolver (property) { return function (value) { resolveAll(property, fulfilled(value)) } } function rejectedResolver (property) { return function (reason) { resolveAll(property, rejected(reason)) } } function resolveAll (property, value) { results[property] = value; if (--remaining === 0) { resolve(results) } } for (let i = 0; i < keys.length; i++) { property = keys[i]; entry = object[property]; if (isNonThenable(entry)) { resolveAll(property, fulfilled(entry)) } else { Promise.resolve(entry).then(fulfilledResolver(property), rejectedResolver(property)) } }
     })
  }; function fulfilled (value) { return { state: 'fulfilled', value } } function rejected (reason) { return { state: 'rejected', reason } }
}); define('rsvp/instrument', ['./config', './utils', 'exports'], (__dependency1__, __dependency2__, __exports__) => {
  const config = __dependency1__.config; const now = __dependency2__.now; __exports__.default = function instrument (eventName, promise, child) { try { config.trigger(eventName, { guid: promise._guidKey + promise._id, eventName, detail: promise._detail, childGuid: child && promise._guidKey + child._id, label: promise._label, timeStamp: now(), stack: new Error(promise._label).stack }) } catch (error) { setTimeout(() => { throw error }, 0) } }
}); define('rsvp/map', ['./promise', './utils', 'exports'], (__dependency1__, __dependency2__, __exports__) => {
   const Promise = __dependency1__.default; const isArray = __dependency2__.isArray; const isFunction = __dependency2__.isFunction; __exports__.default = function map (promises, mapFn, label) {
    return Promise.all(promises, label).then((results) => {
      if (!isArray(promises)) { throw new TypeError('You must pass an array to map.') } if (!isFunction(mapFn)) { throw new TypeError("You must pass a function to map's second argument.") } let resultLen = results.length,
        mappedResults = [],
        i; for (i = 0; i < resultLen; i++) { mappedResults.push(mapFn(results[i])) } return Promise.all(mappedResults, label)
    })
  }
 }); define('rsvp/node', ['./promise', './utils', 'exports'], (__dependency1__, __dependency2__, __exports__) => {
  const Promise = __dependency1__.default; const isArray = __dependency2__.isArray; __exports__.default = function denodeify (nodeFunc, argumentNames) { return function () { const length = arguments.length; const nodeArgs = new Array(length); for (let i = 0; i < length; i++) { nodeArgs[i] = arguments[i] } const asArray = argumentNames === true; const asHash = isArray(argumentNames); let thisArg; if (!asArray && !asHash && argumentNames) { console.warn("Deprecation: RSVP.denodeify() doesn't allow setting the " + '"this" binding anymore. Use yourFunction.bind(yourThis) instead.'); thisArg = argumentNames } else { thisArg = this } return Promise.all(nodeArgs).then((nodeArgs$2) => { return new Promise(resolver); function resolver (resolve, reject) { function callback () { const length$2 = arguments.length; const args = new Array(length$2); for (let i$2 = 0; i$2 < length$2; i$2++) { args[i$2] = arguments[i$2] } const error = args[0]; const value = args[1]; if (error) { reject(error) } else if (asArray) { resolve(args.slice(1)) } else if (asHash) { const obj = {}; const successArguments = args.slice(1); let name; let i$3; for (i$3 = 0; i$3 < argumentNames.length; i$3++) { name = argumentNames[i$3]; obj[name] = successArguments[i$3] }resolve(obj) } else { resolve(value) } }nodeArgs$2.push(callback); nodeFunc.apply(thisArg, nodeArgs$2) } }) } }
}); define('rsvp/promise', ['./config', './events', './instrument', './utils', './promise/cast', './promise/all', './promise/race', './promise/resolve', './promise/reject', 'exports'], (__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __dependency9__, __exports__) => {
  const config = __dependency1__.config; const EventTarget = __dependency2__.default; const instrument = __dependency3__.default; const objectOrFunction = __dependency4__.objectOrFunction; const isFunction = __dependency4__.isFunction; const now = __dependency4__.now; const cast = __dependency5__.default; const all = __dependency6__.default; const race = __dependency7__.default; const Resolve = __dependency8__.default; const Reject = __dependency9__.default; const guidKey = `rsvp_${now()}-`; let counter = 0; function noop () {}__exports__.default = Promise; function Promise (resolver, label) { if (!isFunction(resolver)) { throw new TypeError('You must pass a resolver function as the first argument to the promise constructor') } if (!(this instanceof Promise)) { throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.") } this._id = counter++; this._label = label; this._subscribers = []; if (config.instrument) { instrument('created', this) } if (noop !== resolver) { invokeResolver(resolver, this) } } function invokeResolver (resolver, promise) { function resolvePromise (value) { resolve(promise, value) } function rejectPromise (reason) { reject(promise, reason) } try { resolver(resolvePromise, rejectPromise) } catch (e) { rejectPromise(e) } }Promise.cast = cast; Promise.all = all; Promise.race = race; Promise.resolve = Resolve; Promise.reject = Reject; const PENDING = void 0; const SEALED = 0; const FULFILLED = 1; const REJECTED = 2; function subscribe (parent, child, onFulfillment, onRejection) { const subscribers = parent._subscribers; const length = subscribers.length; subscribers[length] = child; subscribers[length + FULFILLED] = onFulfillment; subscribers[length + REJECTED] = onRejection } function publish (promise, settled) {
    let child,
      callback,
      subscribers = promise._subscribers,
      detail = promise._detail; if (config.instrument) { instrument(settled === FULFILLED ? 'fulfilled' : 'rejected', promise) } for (let i = 0; i < subscribers.length; i += 3) { child = subscribers[i]; callback = subscribers[i + settled]; invokeCallback(settled, child, callback, detail) }promise._subscribers = null
  }Promise.prototype = { constructor: Promise, _id: undefined, _guidKey: guidKey, _label: undefined, _state: undefined, _detail: undefined, _subscribers: undefined, _onerror (reason) { config.trigger('error', reason) }, then (onFulfillment, onRejection, label) { const promise = this; this._onerror = null; const thenPromise = new this.constructor(noop, label); if (this._state) { const callbacks = arguments; config.async(() => { invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail) }) } else { subscribe(this, thenPromise, onFulfillment, onRejection) } if (config.instrument) { instrument('chained', promise, thenPromise) } return thenPromise }, catch (onRejection, label) { return this.then(null, onRejection, label) }, finally (callback, label) { const constructor = this.constructor; return this.then(value => constructor.cast(callback()).then(() => value), reason => constructor.cast(callback()).then(() => { throw reason }), label) } }; function invokeCallback (settled, promise, callback, detail) {
    let hasCallback = isFunction(callback),
       value,
       error,
       succeeded,
       failed; if (hasCallback) { try { value = callback(detail); succeeded = true } catch (e) { failed = true; error = e } } else { value = detail; succeeded = true } if (handleThenable(promise, value)) { } else if (hasCallback && succeeded) { resolve(promise, value) } else if (failed) { reject(promise, error) } else if (settled === FULFILLED) { resolve(promise, value) } else if (settled === REJECTED) { reject(promise, value) }
  } function handleThenable (promise, value) {
     let then = null,
      resolved; try { if (promise === value) { throw new TypeError('A promises callback cannot return that same promise.') } if (objectOrFunction(value)) { then = value.then; if (isFunction(then)) { then.call(value, (val) => { if (resolved) { return true }resolved = true; if (value !== val) { resolve(promise, val) } else { fulfill(promise, val) } }, (val) => { if (resolved) { return true }resolved = true; reject(promise, val) }, `Settle: ${promise._label || ' unknown promise'}`); return true } } } catch (error) { if (resolved) { return true }reject(promise, error); return true } return false
   } function resolve (promise, value) { if (promise === value) { fulfill(promise, value) } else if (!handleThenable(promise, value)) { fulfill(promise, value) } } function fulfill (promise, value) { if (promise._state !== PENDING) { return }promise._state = SEALED; promise._detail = value; config.async(publishFulfillment, promise) } function reject (promise, reason) { if (promise._state !== PENDING) { return }promise._state = SEALED; promise._detail = reason; config.async(publishRejection, promise) } function publishFulfillment (promise) { publish(promise, promise._state = FULFILLED) } function publishRejection (promise) { if (promise._onerror) { promise._onerror(promise._detail) }publish(promise, promise._state = REJECTED) }
}); define('rsvp/promise/all', ['../utils', 'exports'], (__dependency1__, __exports__) => {
  const isArray = __dependency1__.isArray; const isNonThenable = __dependency1__.isNonThenable; __exports__.default = function all (entries, label) {
    const Constructor = this; return new Constructor((resolve, reject) => {
       if (!isArray(entries)) { throw new TypeError('You must pass an array to all.') } let remaining = entries.length; const results = new Array(remaining); let entry,
        pending = true; if (remaining === 0) { resolve(results); return } function fulfillmentAt (index) { return function (value) { results[index] = value; if (--remaining === 0) { resolve(results) } } } function onRejection (reason) { remaining = 0; reject(reason) } for (let index = 0; index < entries.length; index++) { entry = entries[index]; if (isNonThenable(entry)) { results[index] = entry; if (--remaining === 0) { resolve(results) } } else { Constructor.resolve(entry).then(fulfillmentAt(index), onRejection) } }
     }, label)
  }
}); define('rsvp/promise/cast', ['exports'], (__exports__) => {
  __exports__.default = function cast (object, label) { const Constructor = this; if (object && typeof object === 'object' && object.constructor === Constructor) { return object } return new Constructor((resolve) => { resolve(object) }, label) }
}); define('rsvp/promise/race', ['../utils', 'exports'], (__dependency1__, __exports__) => {
   const isArray = __dependency1__.isArray; const isFunction = __dependency1__.isFunction; const isNonThenable = __dependency1__.isNonThenable; __exports__.default = function race (entries, label) {
    let Constructor = this,
       entry; return new Constructor((resolve, reject) => { if (!isArray(entries)) { throw new TypeError('You must pass an array to race.') } let pending = true; function onFulfillment (value) { if (pending) { pending = false; resolve(value) } } function onRejection (reason) { if (pending) { pending = false; reject(reason) } } for (let i = 0; i < entries.length; i++) { entry = entries[i]; if (isNonThenable(entry)) { pending = false; resolve(entry); return } Constructor.resolve(entry).then(onFulfillment, onRejection) } }, label)
  }
 }); define('rsvp/promise/reject', ['exports'], (__exports__) => {
  __exports__.default = function reject (reason, label) { const Constructor = this; return new Constructor((resolve, reject$2) => { reject$2(reason) }, label) }
}); define('rsvp/promise/resolve', ['exports'], (__exports__) => {
   __exports__.default = function resolve (object, label) { const Constructor = this; if (object && typeof object === 'object' && object.constructor === Constructor) { return object } return new Constructor((resolve$2) => { resolve$2(object) }, label) }
 }); define('rsvp/race', ['./promise', 'exports'], (__dependency1__, __exports__) => {
  const Promise = __dependency1__.default; __exports__.default = function race (array, label) { return Promise.race(array, label) }
}); define('rsvp/reject', ['./promise', 'exports'], (__dependency1__, __exports__) => {
  const Promise = __dependency1__.default; __exports__.default = function reject (reason, label) { return Promise.reject(reason, label) }
}); define('rsvp/resolve', ['./promise', 'exports'], (__dependency1__, __exports__) => {
  const Promise = __dependency1__.default; __exports__.default = function resolve (value, label) { return Promise.resolve(value, label) }
}); define('rsvp/rethrow', ['exports'], (__exports__) => {
  __exports__.default = function rethrow (reason) { setTimeout(() => { throw reason }); throw reason }
}); define('rsvp/utils', ['exports'], (__exports__) => {
  function objectOrFunction (x) { return typeof x === 'function' || typeof x === 'object' && x !== null }__exports__.objectOrFunction = objectOrFunction; function isFunction (x) { return typeof x === 'function' }__exports__.isFunction = isFunction; function isNonThenable (x) { return !objectOrFunction(x) }__exports__.isNonThenable = isNonThenable; let _isArray; if (!Array.isArray) { _isArray = function (x) { return Object.prototype.toString.call(x) === '[object Array]' } } else { _isArray = Array.isArray } const isArray = _isArray; __exports__.isArray = isArray; const now = Date.now || function () { return (new Date()).getTime() }; __exports__.now = now; const keysOf = Object.keys || function (object) { const result = []; for (const prop in object) { result.push(prop) } return result }; __exports__.keysOf = keysOf
}); define('rsvp', ['./rsvp/promise', './rsvp/events', './rsvp/node', './rsvp/all', './rsvp/all_settled', './rsvp/race', './rsvp/hash', './rsvp/hash_settled', './rsvp/rethrow', './rsvp/defer', './rsvp/config', './rsvp/map', './rsvp/resolve', './rsvp/reject', './rsvp/filter', './rsvp/asap', 'exports'], (__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __dependency9__, __dependency10__, __dependency11__, __dependency12__, __dependency13__, __dependency14__, __dependency15__, __dependency16__, __exports__) => {
  const Promise = __dependency1__.default; const EventTarget = __dependency2__.default; const denodeify = __dependency3__.default; const all = __dependency4__.default; const allSettled = __dependency5__.default; const race = __dependency6__.default; const hash = __dependency7__.default; const hashSettled = __dependency8__.default; const rethrow = __dependency9__.default; const defer = __dependency10__.default; const config = __dependency11__.config; const configure = __dependency11__.configure; const map = __dependency12__.default; const resolve = __dependency13__.default; const reject = __dependency14__.default; const filter = __dependency15__.default; const asap = __dependency16__.default; config.async = asap; function async (callback, arg) { config.async(callback, arg) } function on () { config.on(...arguments) } function off () { config.off(...arguments) } if (typeof window !== 'undefined' && typeof window.__PROMISE_INSTRUMENTATION__ === 'object') { const callbacks = window.__PROMISE_INSTRUMENTATION__; configure('instrument', true); for (const eventName in callbacks) { if (callbacks.hasOwnProperty(eventName)) { on(eventName, callbacks[eventName]) } } }__exports__.Promise = Promise; __exports__.EventTarget = EventTarget; __exports__.all = all; __exports__.allSettled = allSettled; __exports__.race = race; __exports__.hash = hash; __exports__.hashSettled = hashSettled; __exports__.rethrow = rethrow; __exports__.defer = defer; __exports__.denodeify = denodeify; __exports__.configure = configure; __exports__.on = on; __exports__.off = off; __exports__.resolve = resolve; __exports__.reject = reject; __exports__.async = async; __exports__.map = map; __exports__.filter = filter
});
