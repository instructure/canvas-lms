/*
 * Copyright (C) 2025 - present Instructure, Inc.
 *
 * This file is part of Canvas.
 *
 * Canvas is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, version 3 of the License.
 *
 * Canvas is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

import React from 'react'
import {render, screen, waitFor} from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import {DiscussionTranslationModuleContainer} from '../DiscussionTranslationModuleContainer'
import {DiscussionManagerUtilityContext} from '../../../utils/constants'
import {MockedProvider} from '@apollo/client/testing'
import {useTranslationStore} from '../../../hooks/useTranslationStore'
import {ObserverContext} from '../../../utils/ObserverContext'
import {showFlashAlert} from '@canvas/alerts/react/FlashAlert'

jest.mock('@canvas/alerts/react/FlashAlert')

const mockContextValue = {
  setTranslateTargetLanguage: vi.fn(),
  setShowTranslationControl: vi.fn(),
  clearQueue: vi.fn(),
  translationLanguages: {
    current: [
      {id: 'en', name: 'English', translated_to_name: 'Translated to English'},
      {id: 'es', name: 'Spanish', translated_to_name: 'Translated to Spanish'},
      {id: 'hu', name: 'Hungarian', translated_to_name: 'Translated to Hungarian'},
    ],
  },
}

vi.mock('../../../hooks/useTranslationStore')

const mockSetActiveLanguage = vi.fn()
const mockClearTranslateAll = vi.fn()

const defaultState = {
  entries: [],
  activeLanguage: null,
  translateAll: false,
  setActiveLanguage: mockSetActiveLanguage,
  clearTranslateAll: mockClearTranslateAll,
  setTranslateAll: vi.fn(),
}

const defaultMocks = []

const setup = (overrideContextValue = {}) =>
  render(
    <MockedProvider mocks={defaultMocks}>
      <ObserverContext.Provider
        value={{
          observerRef: {current: undefined},
          nodesRef: {current: new Map()},
          startObserving: vi.fn(),
          stopObserving: vi.fn(),
        }}
      >
        <DiscussionManagerUtilityContext.Provider
          value={{...mockContextValue, ...overrideContextValue}}
        >
          <DiscussionTranslationModuleContainer />
        </DiscussionManagerUtilityContext.Provider>
      </ObserverContext.Provider>
    </MockedProvider>,
  )

describe('DiscussionTranslationModuleContainer', () => {
  beforeAll(() => {
    const node = document.createElement('div')
    node.setAttribute('role', 'alert')
    node.setAttribute('id', 'flash_screenreader_holder')
    document.body.appendChild(node)
  })

  beforeEach(() => {
    vi.clearAllMocks()
    useTranslationStore.mockImplementation(selector => {
      return selector({...defaultState})
    })
  })

  it('renders correctly with default state', () => {
    setup()

    expect(screen.getByText('Translate Discussion')).toBeInTheDocument()
    expect(screen.getByText(/generated by AI/i)).toBeInTheDocument()
    expect(screen.getByRole('button', {name: /translate/i})).toBeInTheDocument()
    expect(screen.getByRole('button', {name: /reset/i})).toBeInTheDocument()
  })

  it('closes translation module without having language selected', async () => {
    setup()

    expect(screen.getByText('Translate Discussion')).toBeInTheDocument()
    const closeButton = screen.getByRole('button', {name: /close translations module/i})
    await userEvent.click(closeButton)
    expect(mockContextValue.setShowTranslationControl).toHaveBeenCalledWith(false)
  })

  it('shows modal when closing translation module with having a language selected', async () => {
    useTranslationStore.mockImplementation(selector => {
      const state = {
        ...defaultState,
        translateAll: true,
      }

      return selector(state)
    })

    setup()

    expect(screen.getByText('Translate Discussion')).toBeInTheDocument()
    const closeButton = screen.getByRole('button', {name: /close translations module/i})
    await userEvent.click(closeButton)
    expect(mockContextValue.setShowTranslationControl).not.toHaveBeenCalled()

    expect(screen.getByText('Are you sure you want to close?')).toBeInTheDocument()
  })

  it('closes translation module closing modal with cancel button', async () => {
    useTranslationStore.mockImplementation(selector => {
      const state = {
        ...defaultState,
        translateAll: true,
      }

      return selector(state)
    })

    setup()

    expect(screen.getByText('Translate Discussion')).toBeInTheDocument()
    const closeButton = screen.getByRole('button', {name: /close translations module/i})
    await userEvent.click(closeButton)
    expect(mockContextValue.setShowTranslationControl).not.toHaveBeenCalled()

    expect(screen.getByText('Are you sure you want to close?')).toBeInTheDocument()
    const modalCancelButton = screen.getByRole('button', {name: /cancel/i})
    await userEvent.click(modalCancelButton)

    await waitFor(async () => {
      expect(await screen.queryByText('Are you sure you want to close?')).not.toBeInTheDocument()
    })
  })

  it('closes translation module with keeping translations', async () => {
    useTranslationStore.mockImplementation(selector => {
      const state = {
        ...defaultState,
        translateAll: true,
      }

      return selector(state)
    })

    setup()

    expect(screen.getByText('Translate Discussion')).toBeInTheDocument()
    const closeButton = screen.getByRole('button', {name: /close translations module/i})
    await userEvent.click(closeButton)
    expect(mockContextValue.setShowTranslationControl).not.toHaveBeenCalled()

    expect(screen.getByText('Are you sure you want to close?')).toBeInTheDocument()
    const closeAndKeepButton = screen.getByRole('button', {name: /close and keep translations/i})
    await userEvent.click(closeAndKeepButton)

    expect(mockContextValue.setShowTranslationControl).toHaveBeenCalledWith(false)
    expect(mockClearTranslateAll).not.toHaveBeenCalled()

    await waitFor(async () => {
      expect(await screen.queryByText('Are you sure you want to close?')).not.toBeInTheDocument()
    })
  })

  it('closes translation module without keeping translations', async () => {
    useTranslationStore.mockImplementation(selector => {
      const state = {
        ...defaultState,
        translateAll: true,
      }

      return selector(state)
    })

    setup()

    expect(screen.getByText('Translate Discussion')).toBeInTheDocument()
    const closeButton = screen.getByRole('button', {name: /close translations module/i})
    await userEvent.click(closeButton)
    expect(mockContextValue.setShowTranslationControl).not.toHaveBeenCalled()

    expect(screen.getByText('Are you sure you want to close?')).toBeInTheDocument()
    const closeAndRemoveButton = screen.getByRole('button', {
      name: /close and remove translations/i,
    })
    await userEvent.click(closeAndRemoveButton)

    expect(mockContextValue.setShowTranslationControl).toHaveBeenCalledWith(false)
    expect(mockClearTranslateAll).toHaveBeenCalled()

    await waitFor(async () => {
      expect(await screen.queryByText('Are you sure you want to close?')).not.toBeInTheDocument()
    })
  })

  it('shows error when translating without selecting a language', async () => {
    setup()

    const translateButton = screen.getByRole('button', {name: /translate/i})
    await userEvent.click(translateButton)

    expect(screen.getAllByText('Please select a language.').length).toBeGreaterThan(0)
  })

  it('allows selecting a language and translating', async () => {
    setup()

    const input = screen.getByPlaceholderText('Select a language...')
    await userEvent.click(input)
    const spanishOption = await screen.findByText('Spanish')
    await userEvent.click(spanishOption)

    const translateButton = screen.getByRole('button', {name: /translate/i})
    await userEvent.click(translateButton)

    expect(mockSetActiveLanguage).toHaveBeenCalledWith('es')
  })

  it('resets translation module', async () => {
    setup()

    const resetButton = screen.getByRole('button', {name: /reset/i})
    await userEvent.click(resetButton)

    const input = screen.getByPlaceholderText('Select a language...')
    expect(input).toHaveValue('')
  })

  describe('screen reader announcements', () => {
    beforeEach(() => {
      showFlashAlert.mockClear()
    })

    it('announces when translation starts loading', async () => {
      useTranslationStore.mockImplementation(selector => {
        const state = {
          ...defaultState,
          entries: {
            entry1: {loading: false},
          },
        }
        return selector(state)
      })

      const {rerender} = setup()

      // Start translation
      const input = screen.getByPlaceholderText('Select a language...')
      await userEvent.click(input)
      const spanishOption = await screen.findByText('Spanish')
      await userEvent.click(spanishOption)

      const translateButton = screen.getByTestId('translate-discussion-button')
      await userEvent.click(translateButton)

      // Simulate loading state
      useTranslationStore.mockImplementation(selector => {
        const state = {
          ...defaultState,
          translateAll: true,
          activeLanguage: 'es',
          entries: {
            entry1: {loading: true},
          },
        }
        return selector(state)
      })

      rerender(
        <MockedProvider mocks={defaultMocks}>
          <ObserverContext.Provider
            value={{
              observerRef: {current: undefined},
              nodesRef: {current: new Map()},
              startObserving: jest.fn(),
              stopObserving: jest.fn(),
            }}
          >
            <DiscussionManagerUtilityContext.Provider value={mockContextValue}>
              <DiscussionTranslationModuleContainer />
            </DiscussionManagerUtilityContext.Provider>
          </ObserverContext.Provider>
        </MockedProvider>,
      )

      await waitFor(() => {
        expect(showFlashAlert).toHaveBeenCalledWith({
          message: 'Translating Discussion',
          srOnly: true,
          politeness: 'polite',
        })
      })
    })

    it('announces when translation completes successfully', async () => {
      useTranslationStore.mockImplementation(selector => {
        const state = {
          ...defaultState,
          translateAll: true,
          activeLanguage: 'es',
          entries: {
            entry1: {loading: true},
          },
        }
        return selector(state)
      })

      const {rerender} = setup()

      // Simulate translation completion
      useTranslationStore.mockImplementation(selector => {
        const state = {
          ...defaultState,
          translateAll: true,
          activeLanguage: 'es',
          entries: {
            entry1: {
              loading: false,
              translatedMessage: 'Hola mundo',
            },
          },
        }
        return selector(state)
      })

      rerender(
        <MockedProvider mocks={defaultMocks}>
          <ObserverContext.Provider
            value={{
              observerRef: {current: undefined},
              nodesRef: {current: new Map()},
              startObserving: jest.fn(),
              stopObserving: jest.fn(),
            }}
          >
            <DiscussionManagerUtilityContext.Provider value={mockContextValue}>
              <DiscussionTranslationModuleContainer />
            </DiscussionManagerUtilityContext.Provider>
          </ObserverContext.Provider>
        </MockedProvider>,
      )

      await waitFor(() => {
        expect(showFlashAlert).toHaveBeenCalledWith({
          message:
            'Discussion description translated to Spanish. Replies will translate as you navigate the page.',
          srOnly: true,
          politeness: 'polite',
        })
      })
    })

    it('announces error when there are translation errors', async () => {
      useTranslationStore.mockImplementation(selector => {
        const state = {
          ...defaultState,
          translateAll: true,
          activeLanguage: 'es',
          entries: {
            entry1: {loading: true},
          },
        }
        return selector(state)
      })

      const {rerender} = setup()

      showFlashAlert.mockClear()

      // Simulate translation error
      useTranslationStore.mockImplementation(selector => {
        const state = {
          ...defaultState,
          translateAll: true,
          activeLanguage: 'es',
          entries: {
            entry1: {
              loading: false,
              error: {type: 'error', message: 'Translation failed'},
            },
          },
        }
        return selector(state)
      })

      rerender(
        <MockedProvider mocks={defaultMocks}>
          <ObserverContext.Provider
            value={{
              observerRef: {current: undefined},
              nodesRef: {current: new Map()},
              startObserving: jest.fn(),
              stopObserving: jest.fn(),
            }}
          >
            <DiscussionManagerUtilityContext.Provider value={mockContextValue}>
              <DiscussionTranslationModuleContainer />
            </DiscussionManagerUtilityContext.Provider>
          </ObserverContext.Provider>
        </MockedProvider>,
      )

      await waitFor(() => {
        expect(showFlashAlert).toHaveBeenCalledWith({
          message: 'Discussion translation failed',
          srOnly: true,
          politeness: 'assertive',
        })
      })
    })

    it('announces when translation is reset', async () => {
      setup()

      const resetButton = screen.getByTestId('reset-translation-button')
      await userEvent.click(resetButton)

      await waitFor(() => {
        expect(showFlashAlert).toHaveBeenCalledWith({
          message: 'Discussion Translation reset',
          srOnly: true,
          politeness: 'polite',
        })
      })
    })

    it('announces for announcements with correct content type', async () => {
      render(
        <MockedProvider mocks={defaultMocks}>
          <ObserverContext.Provider
            value={{
              observerRef: {current: undefined},
              nodesRef: {current: new Map()},
              startObserving: jest.fn(),
              stopObserving: jest.fn(),
            }}
          >
            <DiscussionManagerUtilityContext.Provider value={mockContextValue}>
              <DiscussionTranslationModuleContainer isAnnouncement={true} />
            </DiscussionManagerUtilityContext.Provider>
          </ObserverContext.Provider>
        </MockedProvider>,
      )

      const resetButton = screen.getByTestId('reset-translation-button')
      await userEvent.click(resetButton)

      await waitFor(() => {
        expect(showFlashAlert).toHaveBeenCalledWith({
          message: 'Announcement Translation reset',
          srOnly: true,
          politeness: 'polite',
        })
      })
    })
  })
})
