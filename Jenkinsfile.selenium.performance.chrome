#!/usr/bin/env groovy

/*
 * Copyright (C) 2019 - present Instructure, Inc.
 *
 * This file is part of Canvas.
 *
 * Canvas is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, version 3 of the License.
 *
 * Canvas is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

pipeline {
  agent { label 'canvas-docker' }
  options {
    ansiColor('xterm')
  }

  environment {
    COMPOSE_FILE = 'docker-compose.new-jenkins.yml:docker-compose.new-jenkins-selenium.yml'
    GERRIT_PORT = '29418'
    GERRIT_URL = "$GERRIT_HOST:$GERRIT_PORT"
    MAX_FAIL = 5
    PATCHSET_TAG = "$DOCKER_REGISTRY_FQDN/jenkins/canvas-lms:master"
    RERUNS_RETRY = 0 // no reruns
  }

  stages {
    stage ('Environment Variables') {
      steps {
        timeout(time: 2) {
          sh 'printenv | sort'
        }
      }
    }

    stage ('Pre-Cleanup') {
      steps {
        timeout(time: 2) {
          sh 'build/new-jenkins/docker-cleanup.sh'
        }
      }
    }

    // Copied wholesale out of Jenkinsfile, this needs be abstracted if possible
    stage('Checkout Plugins') {
      steps {
        timeout(time: 10) {
          script {
            def credentials = load 'build/new-jenkins/groovy/credentials.groovy'
            credentials.fetchFromGerrit('gerrit_builder', '.', '', 'canvas-lms/config')
            gems = readFile('gerrit_builder/canvas-lms/config/plugins_list').split()
            println "Plugin list: ${gems}"

            /* fetch plugins */
            gems.each { gem ->
              credentials.fetchFromGerrit(gem, 'gems/plugins')
            }
            credentials.fetchFromGerrit('qti_migration_tool', 'vendor', 'QTIMigrationTool')

            sh '''
              mv -v gerrit_builder/canvas-lms/config/* config/
              mv -v config/knapsack_rspec_report.json ./
              rm -v config/cache_store.yml
              rmdir -p gerrit_builder/canvas-lms/config
              cp -v docker-compose/config/selenium.yml config/
              cp -Rv docker-compose/config/new-jenkins config/new-jenkins
              cp -v config/delayed_jobs.yml.example config/delayed_jobs.yml
              cp -v config/domain.yml.example config/domain.yml
              cp -v config/external_migration.yml.example config/external_migration.yml
              cp -v config/outgoing_mail.yml.example config/outgoing_mail.yml
            '''
          }
        }
      }
    }

    stage ('Setup Containers') {
      steps {
        timeout(time: 20) {
          sh 'build/new-jenkins/docker-compose-pull.sh'
          sh 'build/new-jenkins/docker-compose-pull-selenium.sh'
          sh 'build/new-jenkins/docker-compose-build-up.sh'
        }
      }
    }

    stage ('Setup Databases') {
      steps {
        timeout(time: 5) {
          sh 'build/new-jenkins/docker-compose-create-migrate-database.sh'
        }
      }
    }

    stage ('Selenium Performance Tests') {
      steps {
        timeout(time: 60) {
          sh 'build/new-jenkins/rspec-with-retries.sh performance'
        }
      }
    }
  }

  post {
    success {
      slackSend(
        channel: env.SLACK_CHANNEL,
        color: 'good',
        message: "[${env.JOB_NAME}] <${env.BUILD_URL}|${env.BUILD_DISPLAY_NAME}> was successful."
      )
    }

    unsuccessful {
      // copy spec failures to local
      sh 'mkdir -p tmp'
      // [JIRA CCI-168]: need to handle web container never being spun up
      sh 'docker cp $(docker-compose ps -q web):/usr/src/app/log/spec_failures/ ./tmp'
      script {
        def htmlFiles
        // find all results files
        dir ('tmp') {
          htmlFiles = findFiles glob: '**/index.html'
        }
        // publish html
        publishHTML target: [
          allowMissing: false,
          alwaysLinkToLastBuild: false,
          keepAll: true,
          reportDir: "tmp",
          reportFiles: htmlFiles.join(','),
          reportName: 'Test Failures'
          ]
      }

      slackSend(
        channel: env.SLACK_CHANNEL,
        color: 'danger',
        message: "[${env.JOB_NAME}] <${env.BUILD_URL}|${env.BUILD_DISPLAY_NAME}> was unsuccessful."
      )
    }

    cleanup {
      sh 'rm -rf ./tmp/spec_failures/'
      sh 'build/new-jenkins/docker-cleanup.sh --allow-failure'
    }
  }
}
